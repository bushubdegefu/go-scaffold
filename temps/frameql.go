package temps

import (
	"fmt"
	"os"
	"text/template"
)

func GraphFrame() {
	// ####################################################
	//  graph template
	schema_tmpl, err := template.New("RenderData").Parse(graphSchemaTemplate)
	if err != nil {
		fmt.Println(err)
		panic(err)
	}

	// Create the models directory if it does not exist
	err = os.MkdirAll("gschema", os.ModePerm)
	if err != nil {
		panic(err)
	}

	schema_file, err := os.Create("gschema/schema.graphqls")
	if err != nil {
		panic(err)
	}
	defer schema_file.Close()

	err = schema_tmpl.Execute(schema_file, RenderData)
	if err != nil {
		panic(err)
	}
}
func GraphCurdFrame() {
	// ####################################################
	//  graph template
	schema_tmpl, err := template.New("RenderData").Parse(schemaResolverTemplate)
	if err != nil {
		fmt.Println(err)
		panic(err)
	}

	// Create the models directory if it does not exist
	err = os.MkdirAll("gschema", os.ModePerm)
	if err != nil {
		panic(err)
	}

	schema_file, err := os.Create("gschema/schema.resolvers.go")
	if err != nil {
		panic(err)
	}
	defer schema_file.Close()

	err = schema_tmpl.Execute(schema_file, RenderData)
	if err != nil {
		panic(err)
	}
}

var graphSchemaTemplate = `
# Define the input type for pagination
{{range .Models}}
type {{.Name}} {
	{{range .Fields}} {{.LowerName}}: {{.UpperType}}!
	{{end}}}
input Create{{.Name}}Input {
	{{range .Fields}} {{if .Post}} {{.LowerName}}: {{.UpperType}}!{{end}}
	{{end}}}
input Update{{.Name}}Input {
	{{range .Fields}} {{if .Put}} {{.LowerName}}: {{.UpperType}}!{{end}}
	{{end}}}
{{end}}


# Define the queries
type Query {
{{range .Models}} # Retrieve a paginated list of {{.LowerName}}s
  #create paginated items
  {{.LowerName}}s(page:Int!, size: Int!): [{{.Name}}!]!

  # Retrieve a specific {{.Name}} by its ID
  {{.LowerName}}(id: Int!): {{.Name}}!

  {{ range .Relations }}{{if .MtM}}
  # Retrieve a  list names of {{.FieldName}}s of specfic {{.ParentName}} by its ID
  {{.LowerParentName}}{{.LowerFieldName}}s({{.LowerFieldName}}_id: Int!, {{.LowerParentName}}_id: Int!, page: Int! ,size: Int!): [{{.FieldName}}!]!{{end}}{{end}}
  {{ range .Relations }}{{if .OtM}}
  #Get {{.ParentName}} {{.FieldName}}s
  {{.LowerParentName}}{{.LowerFieldName}}s({{.LowerFieldName}}_id: Int!, {{.LowerParentName}}_id: Int!, page: Int! ,size: Int!): [{{.FieldName}}!]!{{end}}{{end}}
  {{end}}}

# Define the mutations
type Mutation {
  {{range .Models}}# Create a new {{.LowerName}}
  #create object
  create{{.LowerName}}(input: Create{{.Name}}Input!): {{.Name}}!

  # Update an existing {{.LowerName}}
  update{{.LowerName}}(input: Update{{.Name}}Input!): {{.Name}}!

  # Delete an {{.LowerName}} by its ID
  delete{{.LowerName}}(id: Int!): Boolean!

  {{ range .Relations }}{{if .MtM}}
  create{{.LowerFieldName}}{{.LowerParentName}}({{.LowerFieldName}}_id: Int!, {{.LowerParentName}}_id: Int!): {{.FieldName}}!
  delete{{.LowerFieldName}}{{.LowerParentName}}({{.LowerFieldName}}_id: Int!, {{.LowerParentName}}_id: Int!): {{.FieldName}}!{{end}}{{end}}
  {{ range .Relations }}{{if .OtM}}
  create{{.LowerFieldName}}{{.LowerParentName}}({{.LowerFieldName}}_id: Int!, {{.LowerParentName}}_id: Int!): {{.FieldName}}!
  delete{{.LowerFieldName}}{{.LowerParentName}}({{.LowerFieldName}}_id: Int!, {{.LowerParentName}}_id: Int!): {{.FieldName}}!{{end}}{{end}}
  {{end}}
}
`

var schemaResolverTemplate = `
package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"errors"
	"fmt"

	"github.com/mitchellh/mapstructure"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"{{.ProjectName}}.com.com/common"
	"{{.ProjectName}}.com.com/graph/model"
	"{{.ProjectName}}.com.com/models"
)


{{range .Models}}// Create{{.LowerName}} is the resolver for the create{{.LowerName}} field.
func (r *mutationResolver) Create{{.LowerName}}(ctx context.Context, input model.Create{{.Name}}Input) (*model.{{.Name}}, error) {

	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	//created {{.LowerName}} initalization
	create_{{.LowerName}} := new(model.{{.Name}})

	//  initiate -> {{.LowerName}}
	{{.LowerName}} := new(models.{{.Name}})
	{{.LowerName}}.Name = input.Name
	{{.LowerName}}.Description = input.Description

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// add {{.LowerName}} using transaction if values are valid
	if err := tx.Create(&{{.LowerName}}).Error; err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode({{.LowerName}}, &create_{{.LowerName}}); err != nil {
		return nil, err
	}
	return create_{{.LowerName}}, nil

}

// Update{{.LowerName}} is the resolver for the update{{.LowerName}} field.
func (r *mutationResolver) Update{{.LowerName}}(ctx context.Context, input model.Update{{.Name}}Input) (*model.{{.Name}}, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	// updated up for return if transaction success
	update_{{.LowerName}} := new(model.{{.Name}})

	// startng update transaction
	var {{.LowerName}} models.{{.Name}}
	// Check if the record exists
	if err := db.WithContext(tracer.Tracer).First(&{{.LowerName}}, {{.LowerName}}.ID).Error; err != nil {
		return nil, err
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// add {{.LowerName}} using transaction if values are valid
	if err := tx.Model(&{{.LowerName}}).UpdateColumns(*&input).Error; err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode({{.LowerName}}, &update_{{.LowerName}}); err != nil {
		return nil, err
	}
	return update_{{.LowerName}}, nil
}

// Delete{{.LowerName}} is the resolver for the delete{{.LowerName}} field.
func (r *mutationResolver) Delete{{.LowerName}}(ctx context.Context, id uint) (bool, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	// startng update transaction
	var {{.LowerName}} models.{{.Name}}

	// Check if the record exists
	if err := db.WithContext(tracer.Tracer).Where("id = ?",uint(id)).First(&{{.LowerName}}).Error; err != nil {
		return false, err
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// delete {{.LowerName}} using transaction if values are valid
	if err := db.Delete(&{{.LowerName}}).Error; err != nil {
		tx.Rollback()
		return false, err
	}
	// close transaction
	tx.Commit()

	return true, nil
}

// {{.Name}}s is the resolver for getting list of {{.LowerName}}s field.
func (r *queryResolver) {{.Name}}s(ctx context.Context, page uint, size uint) ([]*model.{{.Name}}, error) {

	db := r.DB    			// Database session for querying
	tracer := r.Tracer		// otel collector context and span

	{{.LowerName}}_get := make([]*model.{{.Name}}, 0)
	_, result, err := common.PaginationPureModel(db, models.{{.Name}}{}, []models.{{.Name}}{}, uint(page), uint(size), tracer.Tracer)
	if err != nil {
		return nil, err
	}
	{{.LowerName}} := result.([]models.{{.Name}})

	// filtering response data according to filtered defined struct
	// return error if anything happens
	if err := mapstructure.Decode({{.LowerName}}, &{{.LowerName}}_get); err != nil {
		return nil, err
	}
	return {{.LowerName}}_get, nil
}

// {{.Name}} is the resolver for single {{.LowerName}} field.
func (r *queryResolver) {{.Name}}(ctx context.Context, id uint) (*model.{{.Name}}, error) {
	db := r.DB         		// database connection
	tracer := r.Tracer 		//otel tracer span and context

	var {{.LowerName}} models.{{.Name}}    	// SQL GORM model
	var {{.LowerName}}_get model.{{.Name}} 	// graphql model

	if res := db.WithContext(tracer.Tracer).Model(&models.{{.Name}}{}).Preload(clause.Associations).Where("id = ?", uint(id)).First(&{{.LowerName}}); res.Error != nil {
		if errors.Is(res.Error, gorm.ErrRecordNotFound) {
			return nil, res.Error
		}
		return nil, res.Error
	}

	// filtering response data according to filtered defined struct
	// return error if anything happens
	if err := mapstructure.Decode({{.LowerName}}, &{{.LowerName}}_get); err != nil {
		return nil, err
	}

	return &{{.LowerName}}_get, nil

}
{{end}}

// ###################################################################
// Relationship scaffolding section for Creating, Deleting and Getting
// ###################################################################
{{range .Models}}{{ range .Relations }}{{if .OtM}}
// {{.ParentName}}{{.LowerFieldName}}s is the resolver for the getting {{.LowerParentName}}{{.LowerFieldName}}s field.
func (r *queryResolver) {{.ParentName}}{{.LowerFieldName}}s(ctx context.Context, {{.LowerFieldName}}ID uint, {{.LowerParentName}}ID uint, page uint, size uint) ([]*model.{{.FieldName}}, error) {
	db := r.DB
	tracer := r.Tracer
	{{.LowerFieldName}}_get := make([]*model.{{.FieldName}}, 0)
	_, result, err := common.PaginationPureModelFilterOneToMany(db, models.{{.FieldName}}{}, []models.{{.FieldName}}{}, "{{.LowerParentName}}_id = ?", uint({{.LowerParentName}}ID), uint(page), uint(size), tracer.Tracer)
	if err != nil {
		return nil, err
	}
	{{.LowerFieldName}} := result.([]models.{{.FieldName}})

	// filtering response data according to filtered defined struct
	// return error if anything happens
	if err := mapstructure.Decode({{.LowerFieldName}}, &{{.LowerFieldName}}_get); err != nil {
		return nil, err
	}

	return {{.LowerFieldName}}_get, nil

}
{{end}}{{end}}{{end}}
{{range .Models}}{{ range .Relations }}{{if .MtM}}
// {{.ParentName}}{{.LowerFieldName}}s is the resolver for the getting {{.LowerParentName}}{{.LowerFieldName}}s field.
func (r *queryResolver) {{.ParentName}}{{.LowerFieldName}}s(ctx context.Context, {{.LowerFieldName}}ID uint, {{.LowerParentName}}ID uint, page uint, size uint) ([]*model.{{.FieldName}}, error) {
	db := r.DB
	tracer := r.Tracer
	{{.LowerFieldName}}s_get := make([]*model.{{.FieldName}}, 0)
	join_string := "INNER JOIN {{.LowerParentName}}_{{.LowerFieldName}}s ur ON {{.LowerFieldName}}s.id = ur.{{.LowerFieldName}}_id"
	filter_string := "{{.LowerParentName}}_id = ?"


	//  to make sure no more that 50 items will be queried per request
		if size > 50 {
			size = 50
		}

	// dry run testing join query
	{{.LowerFieldName}}s := []models.{{.FieldName}}{}
	if err := db.WithContext(tracer.Tracer).Model(&models.{{.FieldName}}{}).Joins(join_string).Where(filter_string, {{.LowerParentName}}ID).Order("id asc").Limit(int(size)).Offset(int(page - 1)).Find(&{{.LowerFieldName}}s); err != nil {
		return nil, err.Error
	}


	// filtering response data according to filtered defined struct
	// return error if anything happens
	if err := mapstructure.Decode({{.LowerFieldName}}s, &{{.LowerFieldName}}s_get); err != nil {
		return nil, err
	}

	return {{.LowerFieldName}}s_get, nil

}
{{end}}{{end}}{{end}}

{{range .Models}}{{ range .Relations }}
// Create{{.LowerFieldName}}{{.LowerParentName}} is the resolver for the create{{.LowerFieldName}}{{.LowerParentName}} field.
func (r *mutationResolver) Create{{.LowerFieldName}}{{.LowerParentName}}(ctx context.Context, {{.LowerFieldName}}ID uint, {{.LowerParentName}}ID uint) (*model.{{.FieldName}}, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	//{{.LowerParentName}}_{{.LowerFieldName}} for return if transaction success
	{{.LowerParentName}}_{{.LowerFieldName}} := new(model.{{.FieldName}})

	// updateing {{.LowerFieldName}} transaction
	var {{.LowerParentName}} models.{{.ParentName}}

	// Check if the {{.LowerParentName}} record exists
	if err := db.WithContext(tracer.Tracer).Where("id = ?",{{.LowerParentName}}ID).First(&{{.LowerParentName}}, {{.LowerParentName}}.ID).Error; err != nil {
		return nil, err
	}
	// Check if the {{.LowerFieldName}} record exists
	var {{.LowerFieldName}} models.{{.FieldName}}
	if res := db.WithContext(tracer.Tracer).Model(&models.{{.FieldName}}{}).Where("id = ?", {{.LowerFieldName}}ID).First(&{{.LowerFieldName}}); res.Error != nil {
		return nil, res.Error
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// add {{.LowerFieldName}} to {{.LowerParentName}} data using transaction if values are valid
	if err := db.WithContext(tracer.Tracer).Model(&{{.LowerParentName}}).Association("{{.FieldName}}s").Append(&{{.LowerFieldName}}); err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode({{.LowerFieldName}}, &{{.LowerParentName}}_{{.LowerFieldName}}); err != nil {
		return nil, err
	}
	return {{.LowerParentName}}_{{.LowerFieldName}}, nil
}

// Delete{{.LowerFieldName}}{{.LowerParentName}} is the resolver for the delete{{.LowerFieldName}}{{.LowerParentName}} field.
func (r *mutationResolver) Delete{{.LowerFieldName}}{{.LowerParentName}}(ctx context.Context, {{.LowerFieldName}}ID uint, {{.LowerParentName}}ID uint) (*model.{{.FieldName}}, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	//{{.LowerParentName}}_{{.LowerFieldName}} for return if transaction success
	{{.LowerParentName}}_{{.LowerFieldName}} := new(model.{{.FieldName}})

	// updateing {{.LowerFieldName}} transaction
	var {{.LowerParentName}} models.{{.ParentName}}

	// Check if the {{.LowerParentName}} record exists
	if err := db.WithContext(tracer.Tracer).Where("id = ?",{{.LowerParentName}}ID).First(&{{.LowerParentName}}).Error; err != nil {
		return nil, err
	}

	// Check if the {{.LowerFieldName}} record exists
	var {{.LowerFieldName}} models.{{.FieldName}}
	if res := db.WithContext(tracer.Tracer).Model(&models.{{.FieldName}}{}).Where("id = ?", {{.LowerFieldName}}ID).First(&{{.LowerFieldName}}); res.Error != nil {
		return nil, res.Error
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// delete  data using transaction if values are valid
	if err := db.WithContext(tracer.Tracer).Model(&{{.LowerParentName}}).Association("{{.FieldName}}s").Delete(&{{.LowerFieldName}}); err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode({{.LowerFieldName}}, &{{.LowerParentName}}_{{.LowerFieldName}}); err != nil {
		return nil, err
	}
	return {{.LowerParentName}}_{{.LowerFieldName}}, nil
}
{{end}}{{end}}
`
